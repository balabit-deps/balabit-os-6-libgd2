Backport of:

From a49feeae76d41959d85ee733925a4cf40bac61b2 Mon Sep 17 00:00:00 2001
From: "Christoph M. Becker" <cmbecker69@gmx.de>
Date: Tue, 16 Aug 2016 17:40:23 +0200
Subject: [PATCH] Fix double-free in gdImageWebPtr()

The issue is that gdImageWebpCtx() (which is called by gdImageWebpPtr() and
the other WebP output functions to do the real work) does not return whether
it succeeded or failed, so this is not checked in gdImageWebpPtr() and the
function wrongly assumes everything is okay, which is not, in this case,
because there is a size limitation for WebP, namely that the width and
height must by less than 16383.

We can't change the signature of gdImageWebpCtx() for API compatibility
reasons, so we introduce the static helper _gdImageWebpCtx() which returns
success respective failure, so gdImageWebpPtr() and gdImageWebpPtrEx() can
check the return value. We leave it solely to libwebp for now to report
warnings regarding the failing write.

This issue had been reported by Ibrahim El-Sayed to security@libgd.org.

CVE-2016-6912
---
 src/gd_webp.c                  |  74 +++++++++++++++++++++++++----------------
 tests/webp/.gitignore          |   1 +
 tests/webp/CMakeLists.txt      |   1 +
 tests/webp/Makemodule.am       |   6 ++--
 tests/webp/bug_double_free.c   |  29 ++++++++++++++++
 tests/webp/bug_double_free.jpg | Bin 0 -> 576 bytes
 6 files changed, 81 insertions(+), 30 deletions(-)
 create mode 100644 tests/webp/bug_double_free.c
 create mode 100644 tests/webp/bug_double_free.jpg

Index: libgd2-2.1.1/src/gd_webp.c
===================================================================
--- libgd2-2.1.1.orig/src/gd_webp.c	2017-02-28 10:41:47.438411038 -0500
+++ libgd2-2.1.1/src/gd_webp.c	2017-02-28 10:42:36.458990937 -0500
@@ -106,41 +106,6 @@
 	return im;
 }
 
-BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quantization)
-{
-	gdIOCtx *out = gdNewFileCtx(outFile);
-	gdImageWebpCtx(im, out, quantization);
-	out->gd_free(out);
-}
-
-BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)
-{
-	gdIOCtx *out = gdNewFileCtx(outFile);
-  	gdImageWebpCtx(im, out, -1);
-	out->gd_free(out);
-}
-
-BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)
-{
-	void *rv;
-	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
-	gdImageWebpCtx(im, out, -1);
-	rv = gdDPExtractData(out, size);
-	out->gd_free(out);
-
-	return rv;
-}
-
-BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quantization)
-{
-	void *rv;
-	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
-	gdImageWebpCtx(im, out, quantization);
-	rv = gdDPExtractData(out, size);
-	out->gd_free(out);
-	return rv;
-}
-
 /*
  * Maps normalized QP (quality) to VP8 QP
  */
@@ -164,7 +129,8 @@
  *  and in part on demo code from Chapter 15 of "PNG: The Definitive Guide"
  *  (http://www.cdrom.com/pub/png/pngbook.html).
  */
-BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quantization)
+/* returns 0 on success, 1 on failure */
+static int _gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quantization)
 {
 	int width = im->sx;
 	int height = im->sy;
@@ -181,18 +147,18 @@
 	yuv_height = (height + 1) >> 1;
 
 	if (overflow2(width, height)) {
-		return;
+		return 1;
 	}
 	/* simplification possible, because WebP must not be larger than 16384**2 */
 	if (overflow2(width * height, 2 * sizeof(unsigned char))) {
-		return;
+		return 1;
 	}
 
 	yuv_nbytes = width * height + 2 * yuv_width * yuv_height;
 
 	if ((Y = (unsigned char *)gdCalloc(yuv_nbytes, sizeof(unsigned char))) == NULL) {
 		gd_error("gd-webp error: cannot allocate Y buffer");
-		return;
+		return 1;
 	}
 	vp8_quality = mapQualityToVP8QP(quantization);
 
@@ -210,11 +176,73 @@
 			free(filedata);
 		}
 		gd_error("gd-webp error: WebP Encoder failed");
-		return;
+		return 1;
 	}
 
 	gdPutBuf (filedata, yuv_nbytes, outfile);
 	free(filedata);
+	return 0;
+}
+
+/*
+  Function: gdImageWebpCtx
+
+    Write the image as WebP data via a <gdIOCtx>. See <gdImageWebpEx>
+    for more details.
+
+  Parameters:
+
+    im      - The image to write.
+    outfile - The output sink.
+    quality - Image quality.
+
+  Returns:
+
+    Nothing.
+*/
+BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)
+{
+	_gdImageWebpCtx(im, outfile, quality);
+}
+
+BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quantization)
+{
+	gdIOCtx *out = gdNewFileCtx(outFile);
+	_gdImageWebpCtx(im, out, quantization);
+	out->gd_free(out);
+}
+
+BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)
+{
+	gdIOCtx *out = gdNewFileCtx(outFile);
+  	_gdImageWebpCtx(im, out, -1);
+	out->gd_free(out);
+}
+
+BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)
+{
+	void *rv;
+	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
+	if (_gdImageWebpCtx(im, out, -1)) {
+		rv = NULL;
+	} else {
+		rv = gdDPExtractData(out, size);
+	}
+	out->gd_free(out);
+
+	return rv;
 }
 
+BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quantization)
+{
+	void *rv;
+	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
+	if (_gdImageWebpCtx(im, out, quantization)) {
+		rv = NULL;
+	} else {
+		rv = gdDPExtractData(out, size);
+	}
+	out->gd_free(out);
+	return rv;
+}
 #endif /* HAVE_LIBVPX */
