Backport of:

From 4f8e26f2a40ffaa3a5b77be6a49989a1a42e2b83 Mon Sep 17 00:00:00 2001
From: "Christoph M. Becker" <cmbecker69@gmx.de>
Date: Tue, 16 Aug 2016 14:27:23 +0200
Subject: [PATCH] Fix #290: TGA RLE decoding is broken

We make it work only, for now. Actually, it doesn't make sense that
`oTga::bitmap` is an `int *` as we're storing only bytes there. If this
will be changed, we can even get rid of the `conversion_buffer` in
`read_image_tga` altogether, and read the image data into the
`decompression_buffer` (if RLE'd) or the `tga->bitmap` (if uncompressed)
directly.
---
 src/gd_tga.c                   |  18 ++++++++++--------
 tests/tga/CMakeLists.txt       |   1 +
 tests/tga/Makemodule.am        |   8 ++++++--
 tests/tga/tga_read.c           |  40 ++++++++++++++++++++++++++++++++++++++++
 tests/tga/tga_read_rgb.png     | Bin 0 -> 2349 bytes
 tests/tga/tga_read_rgb.tga     | Bin 0 -> 90444 bytes
 tests/tga/tga_read_rgb_rle.tga | Bin 0 -> 9987 bytes
 7 files changed, 57 insertions(+), 10 deletions(-)
 create mode 100644 tests/tga/tga_read.c
 create mode 100644 tests/tga/tga_read_rgb.png
 create mode 100644 tests/tga/tga_read_rgb.tga
 create mode 100644 tests/tga/tga_read_rgb_rle.tga

Index: libgd2-2.1.1/src/gd_tga.c
===================================================================
--- libgd2-2.1.1.orig/src/gd_tga.c	2017-02-28 10:21:34.452061765 -0500
+++ libgd2-2.1.1/src/gd_tga.c	2017-02-28 10:22:38.160815421 -0500
@@ -191,12 +191,13 @@
 {
 	int pixel_block_size = (tga->bits / 8);
 	int image_block_size = (tga->width * tga->height) * pixel_block_size;
-	uint8_t* decompression_buffer = NULL;
+	int* decompression_buffer = NULL;
 	unsigned char* conversion_buffer = NULL;
 	int buffer_caret = 0;
 	int bitmap_caret = 0;
 	int i = 0;
 	int encoded_pixels;
+	int rle_size;
 
 	if(overflow2(tga->width, tga->height)) {
 		return -1;
@@ -260,7 +261,7 @@
 	 *  Chunk load the pixel data from an RLE compressed RGB type TGA.
 	 */
 	if (tga->imagetype == TGA_TYPE_RGB_RLE) {
-		decompression_buffer = (uint8_t*) gdMalloc(image_block_size * sizeof(uint8_t));
+		decompression_buffer = (int*) gdMalloc(image_block_size * sizeof(int));
 		if (decompression_buffer == NULL) {
 			gdFree( decompression_buffer );
 			return -1;
@@ -273,7 +274,8 @@
 			return -1;
 		}
 
-		if (gdGetBuf(conversion_buffer, image_block_size, ctx) != image_block_size) {
+		rle_size = gdGetBuf(conversion_buffer, image_block_size, ctx);
+		if (rle_size <= 0) {
 			gdFree(conversion_buffer);
 			gdFree(decompression_buffer);
 			return -1;
@@ -281,7 +283,7 @@
 
 		buffer_caret = 0;
 
-		while( buffer_caret < image_block_size ) {
+		while( buffer_caret < rle_size) {
 			decompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret];
 			buffer_caret++;
 		}
@@ -294,14 +296,14 @@
 				encoded_pixels = ( ( decompression_buffer[ buffer_caret ] & ~TGA_RLE_FLAG ) + 1 );
 				buffer_caret++;
 
-				if ((bitmap_caret + (encoded_pixels * pixel_block_size)) >= image_block_size) {
+				if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) {
 					gdFree( decompression_buffer );
 					gdFree( conversion_buffer );
 					return -1;
 				}
 
 				for (i = 0; i < encoded_pixels; i++) {
-					memcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size);
+					memcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, pixel_block_size * sizeof(int));
 					bitmap_caret += pixel_block_size;
 				}
 				buffer_caret += pixel_block_size;
@@ -310,13 +312,13 @@
 				encoded_pixels = decompression_buffer[ buffer_caret ] + 1;
 				buffer_caret++;
 
-				if ((bitmap_caret + (encoded_pixels * pixel_block_size)) >= image_block_size) {
+				if ((bitmap_caret + (encoded_pixels * pixel_block_size)) > image_block_size) {
 					gdFree( decompression_buffer );
 					gdFree( conversion_buffer );
 					return -1;
 				}
 
-				memcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size);
+				memcpy(tga->bitmap + bitmap_caret, decompression_buffer + buffer_caret, encoded_pixels * pixel_block_size * sizeof(int));
 				bitmap_caret += (encoded_pixels * pixel_block_size);
 				buffer_caret += (encoded_pixels * pixel_block_size);
 			}
