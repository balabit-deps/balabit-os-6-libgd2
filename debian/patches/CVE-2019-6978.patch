Backport of:

From 553702980ae89c83f2d6e254d62cf82e204956d0 Mon Sep 17 00:00:00 2001
From: "Christoph M. Becker" <cmbecker69@gmx.de>
Date: Thu, 17 Jan 2019 11:54:55 +0100
Subject: [PATCH] Fix #492: Potential double-free in gdImage*Ptr()

Whenever `gdImage*Ptr()` calls `gdImage*Ctx()` and the latter fails, we
must not call `gdDPExtractData()`; otherwise a double-free would
happen.  Since `gdImage*Ctx()` are void functions, and we can't change
that for BC reasons, we're introducing static helpers which are used
internally.

We're adding a regression test for `gdImageJpegPtr()`, but not for
`gdImageGifPtr()` and `gdImageWbmpPtr()` since we don't know how to
trigger failure of the respective `gdImage*Ctx()` calls.

This potential security issue has been reported by Solmaz Salimi (aka.
Rooney).
---
 src/gd_gif_out.c                  | 18 +++++++++++++++---
 src/gd_jpeg.c                     | 20 ++++++++++++++++----
 src/gd_wbmp.c                     | 21 ++++++++++++++++++---
 tests/jpeg/.gitignore             |  1 +
 tests/jpeg/CMakeLists.txt         |  1 +
 tests/jpeg/Makemodule.am          |  3 ++-
 tests/jpeg/jpeg_ptr_double_free.c | 31 +++++++++++++++++++++++++++++++
 7 files changed, 84 insertions(+), 11 deletions(-)
 create mode 100644 tests/jpeg/jpeg_ptr_double_free.c

Index: libgd2-2.1.1/src/gd_gif_out.c
===================================================================
--- libgd2-2.1.1.orig/src/gd_gif_out.c	2019-02-27 14:32:44.835428828 -0500
+++ libgd2-2.1.1/src/gd_gif_out.c	2019-02-27 14:32:44.831428813 -0500
@@ -93,6 +93,7 @@ static void char_init(GifCtx *ctx);
 static void char_out(int c, GifCtx *ctx);
 static void flush_char(GifCtx *ctx);
 
+static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out);
 
 
 
@@ -125,8 +126,11 @@ BGD_DECLARE(void *) gdImageGifPtr(gdImag
 	void *rv;
 	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) return NULL;
-	gdImageGifCtx(im, out);
-	rv = gdDPExtractData(out, size);
+	if (!_gdImageGifCtx(im, out)) {
+		rv = gdDPExtractData(out, size);
+	} else {
+		rv = NULL;
+	}
 	out->gd_free(out);
 	return rv;
 }
@@ -215,6 +219,12 @@ BGD_DECLARE(void) gdImageGif(gdImagePtr
 */
 BGD_DECLARE(void) gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
 {
+	_gdImageGifCtx(im, out);
+}
+
+/* returns 0 on success, 1 on failure */
+static int _gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
+{
 	gdImagePtr pim = 0, tim = im;
 	int interlace, BitsPerPixel;
 	interlace = im->interlace;
@@ -225,7 +235,7 @@ BGD_DECLARE(void) gdImageGifCtx(gdImageP
 		based temporary image. */
 		pim = gdImageCreatePaletteFromTrueColor(im, 1, 256);
 		if(!pim) {
-			return;
+			return 1;
 		}
 		tim = pim;
 	}
@@ -241,6 +251,8 @@ BGD_DECLARE(void) gdImageGifCtx(gdImageP
 		/* Destroy palette based temporary image. */
 		gdImageDestroy(	pim);
 	}
+
+	return 0;
 }
 
 
Index: libgd2-2.1.1/src/gd_jpeg.c
===================================================================
--- libgd2-2.1.1.orig/src/gd_jpeg.c	2019-02-27 14:32:44.835428828 -0500
+++ libgd2-2.1.1/src/gd_jpeg.c	2019-02-27 14:32:44.831428813 -0500
@@ -118,6 +118,8 @@ static void fatal_jpeg_error(j_common_pt
 	exit(99);
 }
 
+static int _gdImageJpegCtx(gdImagePtr im, gdIOCtx *outfile, int quality);
+
 /*
  * Write IM to OUTFILE as a JFIF-formatted JPEG image, using quality
  * QUALITY.  If QUALITY is in the range 0-100, increasing values
@@ -230,8 +232,11 @@ BGD_DECLARE(void *) gdImageJpegPtr(gdIma
 	void *rv;
 	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) return NULL;
-	gdImageJpegCtx(im, out, quality);
-	rv = gdDPExtractData(out, size);
+	if (!_gdImageJpegCtx(im, out, quality)) {
+		rv = gdDPExtractData(out, size);
+	} else {
+		rv = NULL;
+	}
 	out->gd_free(out);
 	return rv;
 }
@@ -253,6 +258,12 @@ void jpeg_gdIOCtx_dest(j_compress_ptr ci
 */
 BGD_DECLARE(void) gdImageJpegCtx(gdImagePtr im, gdIOCtx *outfile, int quality)
 {
+	_gdImageJpegCtx(im, outfile, quality);
+}
+
+/* returns 0 on success, 1 on failure */
+static int _gdImageJpegCtx(gdImagePtr im, gdIOCtx *outfile, int quality)
+{
 	struct jpeg_compress_struct cinfo;
 	struct jpeg_error_mgr jerr;
 	int i, j, jidx;
@@ -286,7 +297,7 @@ BGD_DECLARE(void) gdImageJpegCtx(gdImage
 		if(row) {
 			gdFree(row);
 		}
-		return;
+		return 1;
 	}
 
 	cinfo.err->emit_message = jpeg_emit_message;
@@ -323,7 +334,7 @@ BGD_DECLARE(void) gdImageJpegCtx(gdImage
 	if(row == 0) {
 		gd_error("gd-jpeg: error: unable to allocate JPEG row structure: gdCalloc returns NULL\n");
 		jpeg_destroy_compress(&cinfo);
-		return;
+		return 1;
 	}
 
 	rowptr[0] = row;
@@ -400,6 +411,7 @@ BGD_DECLARE(void) gdImageJpegCtx(gdImage
 	jpeg_finish_compress(&cinfo);
 	jpeg_destroy_compress(&cinfo);
 	gdFree(row);
+	return 0;
 }
 
 
Index: libgd2-2.1.1/src/gd_wbmp.c
===================================================================
--- libgd2-2.1.1.orig/src/gd_wbmp.c	2019-02-27 14:32:44.835428828 -0500
+++ libgd2-2.1.1/src/gd_wbmp.c	2019-02-27 14:35:27.468006370 -0500
@@ -82,6 +82,8 @@ int gd_getin(void *in)
 	return (gdGetC((gdIOCtx *)in));
 }
 
+static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out);
+
 /* gdImageWBMPCtx
  *  --------------
  *  Write the image as a wbmp file
@@ -93,13 +95,19 @@ int gd_getin(void *in)
  */
 BGD_DECLARE(void) gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)
 {
+	_gdImageWBMPCtx(image, fg, out);
+}
+
+/* returns 0 on success, 1 on failure */
+static int _gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)
+{
 	int x, y, pos;
 	Wbmp *wbmp;
 
 	/* create the WBMP */
 	if((wbmp = createwbmp(gdImageSX(image), gdImageSY(image), WBMP_WHITE)) == NULL) {
 		gd_error("Could not create WBMP\n");
-		return;
+		return 1;
 	}
 
 	/* fill up the WBMP structure */
@@ -115,11 +123,15 @@ BGD_DECLARE(void) gdImageWBMPCtx(gdImage
 
 	/* write the WBMP to a gd file descriptor */
 	if(writewbmp(wbmp, &gd_putout, out)) {
+		freewbmp(wbmp);
 		gd_error("Could not save WBMP\n");
+		return 1;
 	}
 
 	/* des submitted this bugfix: gdFree the memory. */
 	freewbmp(wbmp);
+
+	return 0;
 }
 
 /*
@@ -259,8 +271,11 @@ BGD_DECLARE(void *) gdImageWBMPPtr(gdIma
 	void *rv;
 	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) return NULL;
-	gdImageWBMPCtx(im, fg, out);
-	rv = gdDPExtractData(out, size);
+	if (!_gdImageWBMPCtx(im, fg, out)) {
+		rv = gdDPExtractData(out, size);
+	} else {
+		rv = NULL;
+	}
 	out->gd_free(out);
 	return rv;
 }
Index: libgd2-2.1.1/tests/jpeg/CMakeLists.txt
===================================================================
--- libgd2-2.1.1.orig/tests/jpeg/CMakeLists.txt	2019-02-27 14:32:44.835428828 -0500
+++ libgd2-2.1.1/tests/jpeg/CMakeLists.txt	2019-02-27 14:32:44.831428813 -0500
@@ -1,6 +1,7 @@
 
 SET(TESTS_FILES
 	jpeg_im2im
+	jpeg_ptr_double_free
 	jpeg_null
 	jpeg_read
 	jpeg_empty_file
Index: libgd2-2.1.1/tests/jpeg/jpeg_ptr_double_free.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ libgd2-2.1.1/tests/jpeg/jpeg_ptr_double_free.c	2019-02-27 14:32:44.831428813 -0500
@@ -0,0 +1,31 @@
+/**
+ * Test that failure to convert to JPEG returns NULL
+ *
+ * We are creating an image, set its width to zero, and pass this image to
+ * `gdImageJpegPtr()` which is supposed to fail, and as such should return NULL.
+ *
+ * See also <https://github.com/libgd/libgd/issues/381>
+ */
+
+
+#include "gd.h"
+#include "gdtest.h"
+
+
+int main()
+{
+    gdImagePtr src, dst;
+    int size;
+
+    src = gdImageCreateTrueColor(1, 10);
+    gdTestAssert(src != NULL);
+
+    src->sx = 0; /* this hack forces gdImageJpegPtr() to fail */
+
+    dst = gdImageJpegPtr(src, &size, 0);
+    gdTestAssert(dst == NULL);
+
+    gdImageDestroy(src);
+
+    return gdNumFailures();
+}
